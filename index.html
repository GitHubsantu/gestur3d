<!-- 
  Author: DevOps
  GitHub: https://github.com/githubsantu
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Gesture Controlled 3D Particles</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        
        /* Video Preview */
        #video-container {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 160px;
            height: 120px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            z-index: 10;
            overflow: hidden;
            transform: scaleX(-1); /* Mirror effect */
            box-shadow: 0 0 10px rgba(0,255,255,0.2);
        }
        video { width: 100%; height: 100%; object-fit: cover; }

        /* UI Overlay */
        #ui {
            position: absolute;
            bottom: 30px;
            left: 30px;
            color: rgba(255, 255, 255, 0.9);
            pointer-events: none;
            background: rgba(0, 0, 0, 0.6);
            padding: 20px;
            border-radius: 12px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.1);
        }
        h3 { margin: 0 0 10px 0; font-size: 16px; color: #00ffff; }
        p { margin: 5px 0; font-size: 14px; display: flex; align-items: center; gap: 10px; }
        .key { font-weight: bold; color: #fff; }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

<div id="video-container">
    <video class="input_video"></video>
</div>

<div id="ui">
    <h3>Gesture Controls</h3>
    <p><span>üëå</span> <span class="key">Pinch</span> Switch Shape</p>
    <p><span>üñê</span> <span class="key">Open Palm</span> Explode</p>
    <p><span>‚úä</span> <span class="key">Fist</span> Implode</p>
    <p><span>üëã</span> <span class="key">Move Hand</span> Rotate View</p>
    <hr style="border:0;border-top:1px solid rgba(255,255,255,0.1);margin:12px 0;">
    <p style="font-size:12px;opacity:0.7;">
          Live demo ¬∑ Built with ‚ù§Ô∏è & WebGL by 
          <a href="https://github.com/GitHubsantu/gestur3d"
              target="_blank"
              rel="noopener noreferrer"
              style="color:#00ffff;text-decoration:none;">
              DevOps
          </a>
      </p>
</div>

<script>
    // --- CONFIGURATION ---
    const PARTICLE_COUNT = 15000;
    const PARTICLE_SIZE = 0.18;
    const SHAPE_TRANSITION_SPEED = 0.08;

    // --- 1. THREE.JS SETUP ---
    const scene = new THREE.Scene();
    // Add subtle fog for depth
    scene.fog = new THREE.FogExp2(0x050505, 0.02);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 35;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // --- 2. PARTICLE SYSTEM ---
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(PARTICLE_COUNT * 3);
    const colors = new Float32Array(PARTICLE_COUNT * 3);
    const targetPositions = new Float32Array(PARTICLE_COUNT * 3); // Where particles "want" to be
    const targetColors = new Float32Array(PARTICLE_COUNT * 3);

    // Initial random scatter
    for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
        positions[i] = (Math.random() - 0.5) * 100;
        colors[i] = 1.0;
        targetPositions[i] = positions[i];
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const material = new THREE.PointsMaterial({
        size: PARTICLE_SIZE,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        transparent: true,
        opacity: 0.9
    });

    const particles = new THREE.Points(geometry, material);
    scene.add(particles);

    // --- 3. SHAPE ALGORITHMS ---
    function setShape(type) {
        const posAttr = particles.geometry.attributes.position.array;
        
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const idx = i * 3;
            let x, y, z, r, g, b;

            // Normalized index for distribution
            const ratio = i / PARTICLE_COUNT; 

            if (type === 'sphere') {
                const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
                const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
                const rad = 12;
                
                x = rad * Math.cos(theta) * Math.sin(phi);
                y = rad * Math.sin(theta) * Math.sin(phi);
                z = rad * Math.cos(phi);
                
                // Cyan/Blue Gradient
                r=0.1; g=0.6 + Math.random()*0.4; b=1.0; 

            } else if (type === 'heart') {
                // Parametric Heart
                const t = Math.random() * Math.PI * 2;
                // Distribute points inside the volume roughly
                const scale = 0.6;
                
                // Classic heart formula
                x = 16 * Math.pow(Math.sin(t), 3);
                y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                z = (Math.random() - 0.5) * 6; // Thickness

                x *= scale; y *= scale; z *= scale;
                y += 2; // Center it vertically

                // Red/Pink/Purple
                r=1.0; g=0.1; b=0.4 + Math.random()*0.4;

            } else if (type === 'saturn') {
                if (ratio < 0.6) {
                    // Planet Body
                    const phi = Math.acos(-1 + (2 * (i/0.6)) / PARTICLE_COUNT);
                    const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
                    const rad = 7;
                    x = rad * Math.cos(theta) * Math.sin(phi);
                    y = rad * Math.sin(theta) * Math.sin(phi);
                    z = rad * Math.cos(phi);
                    r=0.9; g=0.7; b=0.4; // Gold
                } else {
                    // Rings
                    const angle = Math.random() * Math.PI * 2;
                    const rad = 9 + Math.random() * 8; // Inner to Outer radius
                    x = rad * Math.cos(angle);
                    z = rad * Math.sin(angle);
                    y = (Math.random() - 0.5) * 0.4; // Very flat
                    
                    // Rotate rings slightly
                    const tilt = 0.3;
                    const tempY = y * Math.cos(tilt) - z * Math.sin(tilt);
                    const tempZ = y * Math.sin(tilt) + z * Math.cos(tilt);
                    y = tempY; z = tempZ;

                    r=0.7; g=0.7; b=0.8; // Grey-ish
                }
            } else if (type === 'flower') {
                // Rose curve (k=4)
                const u = Math.random() * Math.PI * 2;
                const v = Math.random() * Math.PI; // Thickness var
                const rad = 10;
                const k = 3; 
                const r_flower = Math.cos(k * u);
                
                x = rad * r_flower * Math.cos(u) * Math.sin(v);
                y = rad * r_flower * Math.sin(u) * Math.sin(v);
                z = (Math.random()-0.5) * 5;

                // Purple/Green
                r=0.6; g=0.2; b=1.0;
            }

            targetPositions[idx] = x;
            targetPositions[idx+1] = y;
            targetPositions[idx+2] = z;
            
            targetColors[idx] = r;
            targetColors[idx+1] = g;
            targetColors[idx+2] = b;
        }
    }

    // Initialize
    const shapes = ['sphere', 'heart', 'saturn', 'flower'];
    let currentShapeIdx = 0;
    setShape(shapes[0]);

    // --- 4. GESTURE LOGIC ---
    let handExpansion = 0;
    let isPinching = false;
    let lastPinchTime = 0;
    let handRotX = 0;
    let handRotY = 0;

    const videoElement = document.getElementsByClassName('input_video')[0];

    function onHandsResults(results) {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];

            // 1. ROTATION (Palm Center)
            // Landmarks x,y are 0.0 - 1.0. 
            // We map x to rotation Y (left/right), y to rotation X (up/down)
            const palmX = landmarks[9].x; 
            const palmY = landmarks[9].y;
            
            // Smooth target update
            handRotY = (palmX - 0.5) * 3; 
            handRotX = (palmY - 0.5) * 3;

            // 2. EXPANSION (Wrist to Middle Finger Tip distance)
            const wrist = landmarks[0];
            const midTip = landmarks[12];
            // Euclidean distance (ignoring Z for simplicity)
            const handOpenness = Math.sqrt(
                Math.pow(wrist.x - midTip.x, 2) + Math.pow(wrist.y - midTip.y, 2)
            );

            // Tuning: Usually 0.2 is a fist, 0.5 is wide open
            // We map this to expansion factor: -10 (Implode) to 10 (Explode)
            if (handOpenness < 0.25) handExpansion = -15; // Implode
            else if (handOpenness > 0.45) handExpansion = 15; // Explode
            else handExpansion = 0; // Neutral

            // 3. PINCH DETECTION (Thumb tip vs Index tip)
            const thumb = landmarks[4];
            const index = landmarks[8];
            const pinchDist = Math.sqrt(
                Math.pow(thumb.x - index.x, 2) + Math.pow(thumb.y - index.y, 2)
            );

            if (pinchDist < 0.05) {
                const now = Date.now();
                if (!isPinching && now - lastPinchTime > 800) {
                    isPinching = true;
                    lastPinchTime = now;
                    // Trigger Shape Switch
                    currentShapeIdx = (currentShapeIdx + 1) % shapes.length;
                    setShape(shapes[currentShapeIdx]);
                    
                    // Visual Flash
                    document.getElementById('ui').style.borderColor = '#00ffff';
                    setTimeout(() => document.getElementById('ui').style.borderColor = 'rgba(255,255,255,0.1)', 200);
                }
            } else {
                isPinching = false;
            }
        } else {
            // No hands detected, drift back to neutral
            handExpansion = 0;
            handRotX *= 0.95;
            handRotY *= 0.95;
        }
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });
    hands.onResults(onHandsResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 320,
        height: 240
    });
    cameraUtils.start();

    // --- 5. ANIMATION LOOP ---
    let currentExpansion = 0;

    function animate() {
        requestAnimationFrame(animate);

        const positionsArray = particles.geometry.attributes.position.array;
        const colorsArray = particles.geometry.attributes.color.array;

        // Smoothly interpolate the expansion factor
        currentExpansion += (handExpansion - currentExpansion) * 0.1;

        // Smoothly interpolate rotation
        particles.rotation.x += (handRotX - particles.rotation.x) * 0.05;
        particles.rotation.y += (handRotY - particles.rotation.y) * 0.05;

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const idx = i * 3;

            // 1. Get Base Target
            let tx = targetPositions[idx];
            let ty = targetPositions[idx+1];
            let tz = targetPositions[idx+2];

            // 2. Apply Expansion/Implosion Logic
            // Vector from center (0,0,0)
            const len = Math.sqrt(tx*tx + ty*ty + tz*tz) || 0.001;
            const nx = tx / len;
            const ny = ty / len;
            const nz = tz / len;

            // Move target along normal vector based on hand state
            tx += nx * currentExpansion;
            ty += ny * currentExpansion;
            tz += nz * currentExpansion;

            // 3. Move Particle towards Target (Lerp)
            positionsArray[idx] += (tx - positionsArray[idx]) * SHAPE_TRANSITION_SPEED;
            positionsArray[idx+1] += (ty - positionsArray[idx+1]) * SHAPE_TRANSITION_SPEED;
            positionsArray[idx+2] += (tz - positionsArray[idx+2]) * SHAPE_TRANSITION_SPEED;

            // 4. Color Interpolation
            colorsArray[idx] += (targetColors[idx] - colorsArray[idx]) * 0.05;
            colorsArray[idx+1] += (targetColors[idx+1] - colorsArray[idx+1]) * 0.05;
            colorsArray[idx+2] += (targetColors[idx+2] - colorsArray[idx+2]) * 0.05;
        }

        particles.geometry.attributes.position.needsUpdate = true;
        particles.geometry.attributes.color.needsUpdate = true;
        
        // Idle Spin
        particles.rotation.z += 0.002;

        renderer.render(scene, camera);
    }

    animate();

    // Resize Handler
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
